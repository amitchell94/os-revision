Memory management is an optimization task under constraints

Internal Fragmentation: allocated memory may be
slightly larger than requested memory; this size difference is memory
internal to a partition, but not being used

Fixed-partition allocation
- Divide memory into fixed-size partitions
- Each partition contains exactly one process
- The degree of multiprogramming is bound by the
number of partitions
- When a process terminates, the partition becomes
available for other processes
- May lead to Internal Fragmentation

Variable-partition Scheme
- When a process arrives, search for a hole large enough for this process
- Hole – block of available memory; holes of various size are scattered
throughout memory
- Allocate only as much memory as needed
- Operating system maintains information about:
    - allocated partitions
    - free partitions (hole)
- Can lead to External Fragmentation
    -total memory space exists to satisfy a request, but it is not contiguous

Reduce external fragmentation by compaction
    First-fit：Allocate the first hole that is big enough
    Best-fit: Allocate the smallest hole that is big enough; must search entire list, unless ordered by size. Produces the smallest leftover hole.
    Worst-fit: Allocate the largest hole; must also search entire list. Produces the largest leftover hole.
    Next-fit: starts each search at the point of the last allocation (round-robin).
    First-fit is faster
    Best-fit is better in terms of storage utilization
    Worst-fit may lead to less fragmentation

Physical memory (RAM) is a hardware structure consisting of a linear sequence of words.
A word is a fixed-size unit of data. A typical word size is 4 bytes but can also be a single byte.
A logical address space is an abstraction of physical memory, consisting of a sequence of imaginary memory locations.
Source module: program written in language like C, must be translated by a compiler
Object module: machine-language output of a compiler, may be self-contained and executable or many can be linked together into a load module by a linker
Load module: program or many programs in a form ready to be loaded into main memory

Address Binding
- Addresses in source are symbolic. e.g. int count
- Compiler bind symbolic address to relocatable address
- Linkage editor bind relocatable address to absolute address
- Each binding is mapping from one address to another

Address protection between processes
- Base register: smallest legal address space
- Limit register: size of legal range


Memory-Management Unit (MMU)
- Hardware device that maps logical to physical address
- user program deals with logical address
- user program never sees real physical address

HW Address Protection
- CPU checks if in bound, within base register and limit register
- fatal error when attempt to access other process' memory 

Segmentation
- scheme of user view of memory
- A segment is a logical unit. e.g. function, object
- Logical address has two parts: segment-number, offset
- Segment table: maps two-dimensional physical address
    base - starting physical address
    limit - length of segment
- Segment-table base register (STBR): segment table’s location in memory
- Segment-table length register (STLR): length of the segment

Paging - noncontiguous
- physical address of a process can be noncontiguous
- Divide physical/logical memory into fixed sized blocks
- Physical: frames. Logical: pages
- to run program of n pages, need n free frames

Paging Address Translation Scheme
- Address generated by CPU divided into
    Page number (p): index into page table, contains base address
    Page offset (d): combined with base to define physical address

Shared code
- read-only code shared among processes
- must appear in same location in logical address

Private code and data
- process keeps separate copy of code
- can appear in different location in logical address

Pageing
- page table is in main memory
- Page-table base register (PTBR) points to page table
- Page-table length register (PTLR) size of the table
- every data/instruction requires two memory access: page table and data/instruction
- two memory access can solved by associative memory/ translation lookaside buffers(TLBs)

TLB
- small, 64 to 1024 entries
- On TLB miss, value is loaded into TLB for faster access
- entries can be wired down for permanent fast access

Effective Access Time
- α: Hit ratio - percentage of page number found in registers
- M: memory access time
- ε: associative lookup time
- Effective Access Time (EAT) = (Hit Rate x Hit Time) + (Miss Rate x Miss Time)
- EAT = α(M + ε) + (1 - α)(2M + ε) 
- If M ≫ ε → EAT = αM + (1 - α)(2M) = M + (1 - α)M

Memory structures for paging can get huge using straightforward methods

Hierarchical Page Tables
- Break up the logical address space into multiple page tables
- A simple technique is a two-level page table